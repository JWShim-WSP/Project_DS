from django.shortcuts import render
from calendar import HTMLCalendar
import calendar

from datetime import datetime, timedelta, date
from .models import Event
from .forms import EventForm
from todolist.models import ToDoList, ToDoItemList

from django.urls import reverse, reverse_lazy
from django.views import generic
from django.utils.safestring import mark_safe
import pytz
from django.views.generic import ListView, CreateView, UpdateView, DeleteView
from django.core.paginator import Paginator


# Create your views here.
"""
def calendarandtime(request):
    now = datetime.now()
    current_year = now.year
    current_month = now.month
    current_date = now.date
    current_time = now.strftime('%I:%M %p')

    # Convert month from name to number
    #month = month.capitalize()
    #month_number = list(calendar.month_name).index(month)
    #month_number = int(month_number)

    # Create a calendar
    cal = HTMLCalendar().formatmonth(current_year, current_month)

    return render(request, 'calendarandtime/calendarandtime.html', {
        "name": "JW",
        "year": current_year,
        "month_number": current_month,
        "date_number": current_date,
        "calendar": cal,
        "current_year": current_year,
        "current_time": current_time,
    })
"""
MonthName = (
"January",
"February",
"March",
"April",
"May",
"June",
"July",
"August",
"September",
"October",
"November",
"December",
)

class CalendarEvents(ListView):
    model = Event
    context_object_name = 'eventlist'
    template_name = 'calendarwithevent/eventlist.html'

    def get_queryset(self, *args, **kwargs):
        p = Paginator(Event.objects.order_by('-start_date'), 5)
        try:
            return p.get_page(self.request.GET.get("page"))
        except:
            return p.get_page(1)

# CreateView: A view that displays a form for creating an object, redisplaying the form with any validation errors highlighted, and eventually saving the object.
# Therefore, simply call the CBV of ListCreate and ItemCreate will display the form and save the new objects in db
class EventCreate(CreateView):
    form_class = EventForm
    template_name = 'calendarwithevent/event_form.html'

    def get_context_data(self, **kwargs):
        context = super(EventCreate, self).get_context_data(**kwargs)
        context["title"] = "New Event"
        return context
    
    def get_success_url(self):
        return reverse("calendarwithevent:calendarevents")
    
# ItemUpdate will extend the generic view class UpdateView. This is quite similar to CreateView, and you can use the same template for both. The main difference is that the ItemUpdate view will pre-populate the template form with the data from an existing ToDoItem.
# The generic views know how to handle the POST request generated by the form on a successful submit action.
class EventUpdate(UpdateView):
    model = Event
    form_class = EventForm
    template_name = 'calendarwithevent/event_form.html'

    def get_context_data(self, **kwargs):
        context = super(EventUpdate, self).get_context_data(**kwargs)
        context["title"] = "Edit event"
        return context

    def get_success_url(self):
        return reverse("calendarwithevent:calendarevents")

class EventDelete(DeleteView):
    model = Event
    template_name = 'calendarwithevent/event_confirm_delete.html'

    def get_success_url(self):
        return reverse_lazy("calendarwithevent:calendarevents")

class Calendar(HTMLCalendar):
    def __init__(self, year=None, month=None):
        self.year = year
        self.month = month
        super(Calendar, self).__init__()

    # formats a day as a td
    # filter events by day
    def formatday(self, day, events, dateOfToday):
        events_per_day = events.filter(start_date__day=day)
        d = ''
        for event in events_per_day:
            d += f'<li> {event.title} </li>'

        if day != 0:
            if (day == dateOfToday): # Today is the day in the calendar
                return f"<td class='dateoftoday'>{day}<ul> {d} </ul></td>"
            else:
                return f"<td><span class='date'>{day}</span><ul> {d} </ul></td>"
        return '<td></td>'

	# formats a week as a tr 
    def formatweek(self, theweek, events, dateOfToday):
        week = ''
        for d, weekday in theweek:
            week += self.formatday(d, events, dateOfToday)
        return f'<tr> {week} </tr>'

	# formats a month as a table
	# filter events by year and month
    def formatmonth(self, dateOfToday, withyear=True):
        events = Event.objects.filter(start_date__year=self.year, start_date__month=self.month).order_by('-start_date')
        todoitems = ToDoItemList.objects.filter(due_date__year=self.year, due_date__month = self.month).order_by('-due_date')

        cal = f'<table border="0" cellpadding="0" cellspacing="0" class="calendar">\n'
        cal += f'<id=MonthYearofToday>{self.formatmonthname(self.year, self.month, withyear=withyear)}\n' # <tr><th>  </th></tr> is in the function itself (formatmonthname)
        cal += f'{self.formatweekheader()}\n' # <tr><th> </th></tr> is in the function itself (formatweekheader)

        for week in self.monthdays2calendar(self.year, self.month):
            cal += f'{self.formatweek(week, events, dateOfToday)}\n'

        cal +=f'</table>'

        return cal, events, todoitems
	
class CalendarView(generic.ListView):
    model = Event
    template_name = 'calendarwithevent/main.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)

        # use today's date for the calendar or the month selected 
        # request.GET.get('month', None) is saying, if there is any key in the 'query dictionary' starting with 'month', then get the value (prev_month/next_month). If there is no key passed in the GET query, then return the default value of None.
        dateOfToday, d = get_date(self.request.GET.get('month', None))

        # Instantiate our calendar class with today's year and date
        cal = Calendar(d.year, d.month)

        # Call the formatmonth method, which returns our calendar as a table
        html_cal, events, todoitems = cal.formatmonth(dateOfToday, withyear=True)

        p = Paginator(events, 10)
        try:
            event_page = p.get_page(self.request.GET.get("page"))
        except:
            event_page = p.get_page(1)

        context['prev_month'] = prev_month(d)
        context['next_month'] = next_month(d)
        context['calendar'] = mark_safe(html_cal)
        context['events'] = event_page
        context['month'] = MonthName[d.month-1]
        context['todoitems'] = todoitems
        return context

def prev_month(d):
    # get the date of the first day of the month
    first = d.replace(day=1)
    # subtract 1 day from the first day of the current month will get to the date (year/month/day) of the previous month
    prev_month = first - timedelta(days=1)
    # bottom line is to creat a string of "month=2023-2", if the current month is 3 (March)
    month = 'month=' + str(prev_month.year) + '-' + str(prev_month.month)
    return month

def next_month(d):
    # calendar.monthrange returens of weekday (0~6: Monday~Sunday) and days in the month
    days_in_month = calendar.monthrange(d.year, d.month)[1]
    # get the date of the last day of the month of the year
    last = d.replace(day=days_in_month)
    # Add 1 day to the last day of the current month will get to the date (year/month/day) of the next month
    next_month = last + timedelta(days=1)
    # The bottom line is to creat a string of "month=2023-4"
    month = 'month=' + str(next_month.year) + '-' + str(next_month.month)
    return month

def get_date(req_month):
    dateoftoday = datetime.today()
    if req_month:
        year, month = (int(x) for x in req_month.split('-'))
        if (dateoftoday.month == month and dateoftoday.year == year):
            return dateoftoday.day, date(year, month, day=1)
        else:
            return 0, date(year, month, day=1)
    else:
        return dateoftoday.day, dateoftoday
